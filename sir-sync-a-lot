#!/usr/bin/env ruby

require 'yaml'

class SirSyncalot

  def self.run!(*args)
    new(*args).run!
  end

  [:action, :config].each { |member| attr(member) }

  def initialize(action = "sync")
    @action = action
  end

  def run!
    validate_inputs!
    perform_action!
  end

private

  def validate_inputs!
    if setup_action? and config_exists?
      exit_with_error!("Can't make a setup, because there's already a configuration in '#{config_path}'.")
    elsif sync_action? and !config_exists?
      exit_with_error!("Can't make a sync, because there's no configuration, try '#{__FILE__} setup'.")
    end
  end

  def perform_action!
    if setup_action?
      aquire_lock! { perform_setup! }
    elsif sync_action?
      aquire_lock! { perform_sync! }
    elsif help_action?
      display_help!
    else
      exit_with_error!("Cannot perform action '#{@action}', try '#{__FILE__} help' for usage.")
    end
  end

  def setup_action?
    action == "setup"
  end

  def sync_action?
    action == "sync"
  end

  def help_action?
    action == "help"
  end

  def perform_setup!
    display("Hello! Ima ask you a few questions, and store the results in #{config_path} for later, OK?")

    config = {}

    config[:aws_access_key] = ask("What is the AWS access key?")
    config[:aws_secret_key] = ask("What is the AWS secret access key?")
    display("Just a sec, ima check that works...")
    if aws_credentials_valid?(config)
      display("Yep, all good.")
      config[:aws_dest_bucket] = ask("What bucket should we put your backups in? (If it doesn't exist I'll create it)")
      if bucket_exists?(config)
        if bucket_empty?(config)
          display("I found that the bucket already exists, and it's empty so I'm happy.")
        else
          exit_with_error!("I found the bucket to exist, but it's not empty. I can't sync to a bucket that is not empty.")
        end
      else
        display("The bucket doesn't exist, so I'm creating it now...")
        create_bucket(config)
        display("OK that's done.")
      end
    else
      exit_with_error!("I couldn't connect to S3 with the credentials you supplied, try again much?")
    end

    config[:local_file_path] = ask("What is the (absolute) path that you want to back up? (i.e. /var/www not ./www)")
    if !local_file_path_exists?(config)
      exit_with_error!("I find that the local file path you supplied doesn't exist, wrong much?")
    end

    config[:find_options] = ask("Do you have any options for find ? (e.g. \! -path \"*.git*). Press enter for defaults.")

    display("Right, I'm writing out the details you supplied to '#{config_path}' for my future reference...")
    write_config!(config)
    display("You're good to go. Next up is '#{__FILE__} sync' to syncronise your files to S3.")
  end

  def aws_credentials_valid?(config = read_config())
    true # implement this
  end

  def bucket_exists?(config = read_config())
    true # implement this
  end

  def bucket_empty?(config = read_config())
    true # implement this
  end

  def create_bucket(config = read_config())
    # implement this
  end

  def local_file_path_exists?(config = read_config())
    true # implement this
  end

  def write_config!(config)
    open(config_path, 'w') { |f| YAML::dump(config, f) }
  end

  def read_config(reload = false)
    reload or !@config ? @config = open(config_path, 'r') { |f| YAML::load(f) } : @config
  end

  def perform_sync!
    if !aws_credentials_valid?
      exit_with_error("Couldn't connect to S3 with the credentials in #{config_path}.")
    end

    if !bucket_exists?
      exit_with_error("Can't find the bucket in S3 specified in #{config_path}.")
    end

    if !local_file_path_exists?
      exit_with_error("Local path specified in #{config_path} does not exist.")
    end

    if last_sync_recorded?
      sync_start = Time.now
      # as the backup is stateful, using find -ctime is way less resource intensive
      local_files_changed_since_last_sync.each { |file| push_file(file) }
      mark_last_sync!(sync_start)
    else
      # note that we do not remove files on s3 that no longer exist on local host. this behaviour
      # may be desirable (ala rsync --delete) but we currently don't support it. ok? sweet.
      (new_or_changed_files = files_on_localhost - files_on_s3).each { |file| push_file(file) }
    end
  end

  def local_files_changed_since_last_sync
    # use find -ctime from the state, 
  end

  def files_on_localhost
    # return uniform list of path w/ checksum, using find w/ xargs and openssl md5
  end

  def files_on_s3
    # return uniform key w/ checksum
  end

  def push_file
    # xfer speed, logging, etc can occur in this method
  end

  def mark_last_sync!(time)
    # write out last sync to config file, or something
  end

  def aquire_lock!
    if File.exist?(lock_path)
      exit_with_error("Found a lock at #{lock_path}, is another instance of #{__FILE__} running?")
    else
      system("touch #{lock_path}")
    end

    yield
  ensure
    system("rm #{lock_path}")
  end


  def display_help!
    display("Go help yourself buddy!")
  end

  def exit_with_error!(message)
    display("ERROR: " + message)
    exit
  end

  def display(message)
    puts(message)
  end

  def ask(question)
    print(question + ": ")
    $stdin.readline.chomp # gets doesn't work here!
  end

  def config_exists?
    File.exist?(config_path)
  end

  def config_path
    ENV['HOME'] + "/.sir-sync-a-lot.yml"
  end

  def lock_path
    ENV['HOME'] + "/.sir-sync-a-lot.lock"
  end

end

SirSyncalot.run!(*ARGV)
